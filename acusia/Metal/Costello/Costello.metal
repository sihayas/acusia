#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

// Constants
constant float PI = 3.14159265359;
//constant float HALF_PI = 1.57079632675;
constant float TWO_PI = 6.283185307;
constant float SECONDS = 6.0;

// Make each section react differently to a unique input (seed)
constant uint32_t TOP_LEFT_ID = 2236067977u;
constant uint32_t TOP_RIGHT_ID = 2718281828u;
constant uint32_t BOTTOM_RIGHT_ID = 3141592653u;

// Intensity of a wave generated by a unique input (seed)
constant float TOP_LEFT_WAVE_INTENSITY = 10.0;
constant float TOP_RIGHT_WAVE_INTENSITY = 10.0;
constant float BOTTOM_RIGHT_WAVE_INTENSITY = 10.0;

struct Uniforms {
    float time;
    float2 resolution;
    uint uniqueTopLeftInput;
    uint uniqueTopRightInput;
    uint uniqueBottomRightInput;
    float topLeftThickness;
    float topRightThickness;
    float bottomRightThickness;
    float animationProgress;
};

struct WaveParams {
    float center;
    float radius;
    float intensity;
    float spikiness;
    uint32_t hash;
};

float hash(uint32_t x) {
    x ^= x >> 16;
    x *= 0x7feb352du;
    x ^= x >> 15;
    x *= 0x846ca68bu;
    x ^= x >> 16;
    return float(x) / 4294967296.0;
}

// Difference in behavior between GLSL's mod function and Metal's fmod function.
float mod(float x, float y) {
    return x - y * floor(x / y);
}

WaveParams generateUniqueWaveParams(uint32_t sectionId, float baseIntensity, constant Uniforms &uniforms) {
    uint32_t seed;
    if (sectionId == BOTTOM_RIGHT_ID) seed = uniforms.uniqueBottomRightInput + sectionId;
    else if (sectionId == TOP_RIGHT_ID) seed = uniforms.uniqueTopRightInput + sectionId;
    else seed = uniforms.uniqueTopLeftInput + sectionId;

    float center = hash(seed);
    float radius = 0.05 + hash(seed * 31u) * 0.05;  // Range: 0.05-0.1
    float intensity = baseIntensity * (0.8 + hash(seed * 37u) * 0.4);
    float spikiness = 1.0 + hash(seed * 41u) * 4.0;  // Range: 1.0-5.0
    return WaveParams{center, radius, intensity, spikiness, seed};
}


float generateWave(float angle, float time, uint32_t sectionId, float waveIntensity, float spikiness) {
    if (waveIntensity == 0.0) return 0.0;
    float frequency = 10.0 + hash(sectionId) * 20.0;  // Range: 10-30
    float speed = 0.5 + hash(sectionId * 31u) * 2.0;  // Range: 0.5-2.5
    float baseAmplitude = 0.001 + hash(sectionId * 37u) * 0.004;  // Range: 0.001-0.005
    
    float amplitude = baseAmplitude * waveIntensity;
    
    return sin(angle * frequency * spikiness + time * speed) * amplitude;
}

float getLocalWaveEffect(float normalizedAngle, float time, uint32_t sectionId, float baseIntensity, constant Uniforms &uniforms) {
    WaveParams waveParams = generateUniqueWaveParams(sectionId, baseIntensity, uniforms);
    float distFromCenter = abs(normalizedAngle - waveParams.center);
    distFromCenter = min(distFromCenter, 1.0 - distFromCenter);
    
    float localWaveIntensity = smoothstep(waveParams.radius, 0.0, distFromCenter);
    return generateWave(normalizedAngle, time, waveParams.hash, waveParams.intensity * localWaveIntensity, waveParams.spikiness);
}

float getThicknessWithWave(float angle, constant Uniforms &uniforms) {
    float normalizedAngle = mod(angle / (2.0 * PI), 1.0);
    
    float section1 = 0.20;  // Top right ends
    float section2 = 0.45;  // Top left ends
    float section3 = 0.55;  // Bottom left (thin section) ends
    float section4 = 0.80;  // Bottom right ends

    float thickness3 = mix(0.01, 0.05, uniforms.topLeftThickness / 2000.0);
    float thickness2 = mix(0.01, 0.05, uniforms.topRightThickness / 2000.0);
    float thickness1 = mix(0.01, 0.05, uniforms.bottomRightThickness / 2000.0);
    float minThickness = 0.005; // bottom left (thin section)

    float wave1 = getLocalWaveEffect(normalizedAngle, uniforms.time, BOTTOM_RIGHT_ID, BOTTOM_RIGHT_WAVE_INTENSITY, uniforms);
    float wave2 = getLocalWaveEffect(normalizedAngle, uniforms.time, TOP_RIGHT_ID, TOP_RIGHT_WAVE_INTENSITY, uniforms);
    float wave4 = getLocalWaveEffect(normalizedAngle, uniforms.time, TOP_LEFT_ID, TOP_LEFT_WAVE_INTENSITY, uniforms);

    float thickness;
    if (normalizedAngle < section1) {
        thickness = mix(thickness2, thickness1, smoothstep(0.0, section1, normalizedAngle));
        thickness += mix(wave1, wave2, smoothstep(0.0, section1, normalizedAngle));
    } else if (normalizedAngle < section2) {
        thickness = mix(thickness1, minThickness, smoothstep(section1, section2, normalizedAngle));
        thickness += mix(wave2, 0.0, smoothstep(section1, section2, normalizedAngle));
    } else if (normalizedAngle < section3) {
        thickness = minThickness; // Constant thin section, no wave
    } else if (normalizedAngle < section4) {
        thickness = mix(minThickness, thickness3, smoothstep(section3, section4, normalizedAngle));
        thickness += mix(0.0, wave4, smoothstep(section3, section4, normalizedAngle));
    } else {
        thickness = mix(thickness3, thickness2, smoothstep(section4, 1.0, normalizedAngle));
        thickness += mix(wave4, wave1, smoothstep(section4, 1.0, normalizedAngle));
    }

    return max(thickness, 0.001);
}

float2 random2(float2 st) {
    st = float2(dot(st, float2(127.1, 311.7)),
                dot(st, float2(29.5, 183.3)));
    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);
}

float random(float2 st) {
    return fract(sin(dot(st.yx, float2(14.7891, 43.123))) * 312991.41235);
}

float random(float x) {
    return fract(sin(x) * 43758.5453123);
}

// iq's value noise function
float v_noise(float2 st) {
    float2 i = floor(st);
    float2 f = fract(st);

    float2 u = f * f * (3.0 - 2.0 * f);

    return mix(mix(dot(random2(i + float2(0.0, 0.0)), f - float2(0.0, 0.0)),
                   dot(random2(i + float2(1.0, 0.0)), f - float2(1.0, 0.0)), u.x),
               mix(dot(random2(i + float2(0.0, 1.0)), f - float2(0.0, 1.0)),
                   dot(random2(i + float2(1.0, 1.0)), f - float2(1.0, 1.0)), u.x), u.y);
}

float2x2 rotate(float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return float2x2(c, -s, s, c);
}

float2 ratio(float2 st) {
    return float2(max(st.x / st.y, 1.0),
                  max(st.y / st.x, 1.0));
}

float2 center(float2 st, float2 resolution) {
    float aspect = resolution.x / resolution.y;
    st.x = st.x * aspect - aspect * 0.5 + 0.5;
    return st;
}

float3 time(float iTime) {
    float period = mod(iTime, SECONDS);
    return float3(fract(iTime / SECONDS), period, 1.0 - fract(period));
}

float scene(float2 st, constant Uniforms &uniforms) {
    st = st * 2.0 - 1.0;

    float seed = 29192.173;
    float n_scale = 0.05; // Change Wobbling

    float n_1 = v_noise(st) * n_scale;
    float n_2 = v_noise(st + seed) * n_scale;

    float r = random(seed);
    float r_scalar = r * 2.0 - 1.0;

    float2 pos = st - float2(0.0);
    pos += float2(0.01) * (rotate(TWO_PI * r_scalar) * pos);
    pos = rotate(TWO_PI * r_scalar + v_noise(pos + uniforms.time)) * pos;
    pos += mix(n_1, n_2, 0.5);

    float s = 0.45 + 0.126 * r;

    float angle = atan2(pos.y, pos.x);
    float thickness = getThicknessWithWave(angle, uniforms);
    
    float c = length(pos);
    c = abs(c - s);
    c -= thickness;
    
    return c;
}

kernel void mainImage(texture2d<float, access::write> outputTexture [[texture(0)]],
                      constant Uniforms &uniforms [[buffer(0)]],
                      uint2 gid [[thread_position_in_grid]]) {
    float2 fragCoord = float2(gid);

    // space
    float2 st = fragCoord / uniforms.resolution;
    st = center(st, uniforms.resolution);

    // scene
    float s = scene(st, uniforms);

    // aa
    float pixelSmoothing = 2.0;
    float aa = ratio(uniforms.resolution).x / uniforms.resolution.x * pixelSmoothing;
    
    // color
    float3 color = float3(1.0);  // Changed this to white (1.0, 1.0, 1.0)
    color = mix(color, float3(0.0), smoothstep(-aa, aa, s));  // Invert the mix
    // Removed the color inversion: color = 1.0 - color;

//    float d = v_noise(st * 7.0 + iTime * 0.25);
    
    float4 fragColor = float4(color, 1.0);
    
    outputTexture.write(fragColor, gid);
}
